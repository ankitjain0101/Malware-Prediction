import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm, tqdm_notebook
from sklearn.model_selection import train_test_split, KFold, StratifiedKFold
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
from sklearn.impute import SimpleImputer
import lightgbm as lgb
from sklearn.metrics import roc_auc_score
from numba import jit

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        }

data = pd.read_csv('E:/College/Analytics/Python/microsoft-malware-prediction/train.csv',dtype=dtypes)
data.shape
data.info()

test  = pd.read_csv('E:/College/Analytics/Python/microsoft-malware-prediction/test.csv',dtype=dtypes)
test.shape

stats = []
for col in data.columns:
    stats.append((col, data[col].nunique(), data[col].isnull().sum() * 100 / data.shape[0],data[col].value_counts(normalize=True, dropna=False).values[0] * 100))
    
stats_df = pd.DataFrame(stats, columns=['Feature', 'Unique_values', 'Percentage of missing values','Percentage of values in the biggest category'])
stats_df.sort_values('Percentage of values in the biggest category', ascending=False).head(25)

data['SmartScreen'] = data['SmartScreen'].str.lower()
data['SmartScreen'].replace(
    {'promt': 'prompt', 
    'promprt': 'prompt',
    'enabled': 'on',
    'of': 'off',
    'deny': '0',
    '00000000': '0',
    'requiredadmin': 'requireadmin'},
     inplace=True)

data['SmartScreen'].replace({'0': np.nan}, inplace=True)
data['SmartScreen'] = data['SmartScreen'].astype('category')

data['Census_InternalPrimaryDisplayResolutionHorizontal'].replace({-1: np.nan}, inplace=True)
data['Census_InternalPrimaryDisplayResolutionVertical'].replace({-1: np.nan}, inplace=True)

data['OsBuildLab'] = data['OsBuildLab'].cat.add_categories(['0.0.0.0.0-0'])
data['OsBuildLab'] = data['OsBuildLab'].fillna('0.0.0.0.0-0')

test['SmartScreen'] = test['SmartScreen'].str.lower()
test['SmartScreen'].replace(
    {'promt': 'prompt', 
    'promprt': 'prompt',
    'enabled': 'on',
    'of': 'off',
    'deny': '0',
    '00000000': '0',
    'requiredadmin': 'requireadmin'},
     inplace=True)
test['SmartScreen'].replace({'0': np.nan}, inplace=True)
test['SmartScreen'] = test['SmartScreen'].astype('category')
test['Census_InternalPrimaryDisplayResolutionHorizontal'].replace({-1: np.nan}, inplace=True)
test['Census_InternalPrimaryDisplayResolutionVertical'].replace({-1: np.nan}, inplace=True)

def isnan(feature):
    return 1 if np.isnan(float(feature)) else 0
# Create a binary feature indicating that a missing value has been imputed for train/test
data['core_nan'] = data['Census_ProcessorCoreCount'].apply(isnan).astype('uint8')
data['ram_nan'] = data['Census_TotalPhysicalRAM'].apply(isnan).astype('uint8')
data['primary_nan'] = data['Census_PrimaryDiskTotalCapacity'].apply(isnan).astype('uint8')
data['system_nan'] = data['Census_SystemVolumeTotalCapacity'].apply(isnan).astype('uint8')
data['diagonal_nan'] = data['Census_InternalPrimaryDiagonalDisplaySizeInInches'].apply(isnan).astype('uint8')
data['horizonal_nan'] = data['Census_InternalPrimaryDisplayResolutionHorizontal'].apply(isnan).astype('uint8')
data['vertical_nan'] = data['Census_InternalPrimaryDisplayResolutionVertical'].apply(isnan).astype('uint8')
data['charges_nan'] = data['Census_InternalBatteryNumberOfCharges'].apply(isnan).astype('uint8')

test['core_nan'] = test['Census_ProcessorCoreCount'].apply(isnan).astype('uint8')
test['ram_nan'] = test['Census_TotalPhysicalRAM'].apply(isnan).astype('uint8')
test['primary_nan'] = test['Census_PrimaryDiskTotalCapacity'].apply(isnan).astype('uint8')
test['system_nan'] = test['Census_SystemVolumeTotalCapacity'].apply(isnan).astype('uint8')
test['diagonal_nan'] = test['Census_InternalPrimaryDiagonalDisplaySizeInInches'].apply(isnan).astype('uint8')
test['horizonal_nan'] = test['Census_InternalPrimaryDisplayResolutionHorizontal'].apply(isnan).astype('uint8')
test['vertical_nan'] = test['Census_InternalPrimaryDisplayResolutionVertical'].apply(isnan).astype('uint8')
test['charges_nan'] = test['Census_InternalBatteryNumberOfCharges'].apply(isnan).astype('uint8')

imputer = SimpleImputer(strategy='median')

data['Census_InternalBatteryNumberOfCharges'] = imputer.fit_transform(data['Census_InternalBatteryNumberOfCharges'].values.reshape(-1,1))
test['Census_InternalBatteryNumberOfCharges'] = imputer.transform(test['Census_InternalBatteryNumberOfCharges'].values.reshape(-1,1))
data['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = imputer.fit_transform(data['Census_InternalPrimaryDiagonalDisplaySizeInInches'].values.reshape(-1,1))
test['Census_InternalPrimaryDiagonalDisplaySizeInInches'] = imputer.transform(test['Census_InternalPrimaryDiagonalDisplaySizeInInches'].values.reshape(-1,1))
data['Census_ProcessorCoreCount'] = imputer.fit_transform(data['Census_ProcessorCoreCount'].values.reshape(-1,1))
test['Census_ProcessorCoreCount'] = imputer.transform(test['Census_ProcessorCoreCount'].values.reshape(-1,1))
data['Census_TotalPhysicalRAM'] = imputer.fit_transform(data['Census_TotalPhysicalRAM'].values.reshape(-1,1))
test['Census_TotalPhysicalRAM'] = imputer.transform(test['Census_TotalPhysicalRAM'].values.reshape(-1,1))
data['Census_PrimaryDiskTotalCapacity'] = imputer.fit_transform(data['Census_PrimaryDiskTotalCapacity'].values.reshape(-1,1))
test['Census_PrimaryDiskTotalCapacity'] = imputer.transform(test['Census_PrimaryDiskTotalCapacity'].values.reshape(-1,1))
data['Census_SystemVolumeTotalCapacity'] = imputer.fit_transform(data['Census_SystemVolumeTotalCapacity'].values.reshape(-1,1))
test['Census_SystemVolumeTotalCapacity'] = imputer.transform(test['Census_SystemVolumeTotalCapacity'].values.reshape(-1,1))
data['Census_InternalPrimaryDisplayResolutionHorizontal'] = imputer.fit_transform(data['Census_InternalPrimaryDisplayResolutionHorizontal'].values.reshape(-1,1))
test['Census_InternalPrimaryDisplayResolutionHorizontal'] = imputer.transform(test['Census_InternalPrimaryDisplayResolutionHorizontal'].values.reshape(-1,1))
data['Census_InternalPrimaryDisplayResolutionVertical'] = imputer.fit_transform(data['Census_InternalPrimaryDisplayResolutionVertical'].values.reshape(-1,1))
test['Census_InternalPrimaryDisplayResolutionVertical'] = imputer.transform(test['Census_InternalPrimaryDisplayResolutionVertical'].values.reshape(-1,1))

data[data.isnull().any(axis=1)]
data[data.isnull().any(axis=0)]


# total disk capacity remaining
data['disk_remain'] = data['Census_PrimaryDiskTotalCapacity'] - data['Census_SystemVolumeTotalCapacity']
test['disk_remain'] = test['Census_PrimaryDiskTotalCapacity'] - test['Census_SystemVolumeTotalCapacity']
data['disk_remain'] = data['disk_remain'].astype('float32')
test['disk_remain'] = test['disk_remain'].astype('float32')

# Ram-to-CPU ratio
data['ram_cpu_ratio'] = data['Census_TotalPhysicalRAM'] / data['Census_ProcessorCoreCount']
test['ram_cpu_ratio'] = test['Census_TotalPhysicalRAM'] / test['Census_ProcessorCoreCount']

# Pixel Per Inch PPI sqrt(horizonal**2 + vertical**2) / diagonal
data['ppi'] = np.sqrt(data['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + data['Census_InternalPrimaryDisplayResolutionVertical']**2) / data['Census_InternalPrimaryDiagonalDisplaySizeInInches']
test['ppi'] = np.sqrt(test['Census_InternalPrimaryDisplayResolutionHorizontal']**2 + test['Census_InternalPrimaryDisplayResolutionVertical']**2) / test['Census_InternalPrimaryDiagonalDisplaySizeInInches']

# PPI squared
data['ppi2'] = data.ppi ** 2
test['ppi2'] = test.ppi ** 2

# Screen aspect ratio = Horizonal / Vertical
data['aspect_ratio'] = data['Census_InternalPrimaryDisplayResolutionHorizontal'] / data['Census_InternalPrimaryDisplayResolutionVertical']
test['aspect_ratio'] = test['Census_InternalPrimaryDisplayResolutionHorizontal'] / test['Census_InternalPrimaryDisplayResolutionVertical']

# Pixel count = Horizonal * Vertical
data['pixel_count'] = data['Census_InternalPrimaryDisplayResolutionHorizontal'] * data['Census_InternalPrimaryDisplayResolutionVertical']
test['pixel_count'] = test['Census_InternalPrimaryDisplayResolutionHorizontal'] * test['Census_InternalPrimaryDisplayResolutionVertical']

numerical_categorical = [
'RtpStateBitfield','DefaultBrowsersIdentifier', 'AVProductStatesIdentifier', 
'CityIdentifier' , 'OrganizationIdentifier','GeoNameIdentifier', 
'IeVerIdentifier', 'UacLuaenable', 'Census_OEMNameIdentifier', 
'Census_OEMModelIdentifier', 'Census_ProcessorManufacturerIdentifier', 
'Census_ProcessorModelIdentifier', 'Census_OSInstallLanguageIdentifier', 
'Census_FirmwareManufacturerIdentifier', 'Census_FirmwareVersionIdentifier', 
'Wdft_RegionIdentifier', 'LocaleEnglishNameIdentifier', 'OsBuild', 'OsSuite', 
'Census_OSBuildNumber', 'CountryIdentifier', 'Census_OSUILocaleIdentifier', 'Census_OSBuildRevision'
]
categorical = [
'ProductName', 'Platform', 'Processor', 'OsVer', 'OsPlatformSubRelease', 
'OsBuildLab', 'SkuEdition', 'PuaMode', 'SmartScreen', 'Census_MDC2FormFactor', 
'Census_DeviceFamily', 'Census_ProcessorClass', 'Census_PrimaryDiskTypeName', 
'Census_ChassisTypeName', 'Census_PowerPlatformRoleName', 'Census_InternalBatteryType', 
'Census_OSArchitecture', 'Census_OSBranch', 'Census_OSEdition', 'Census_OSSkuName', 
'Census_OSInstallTypeName', 'Census_OSWUAutoUpdateOptionsName', 'Census_GenuineStateName', 
'Census_ActivationChannel', 'Census_FlightRing', 
 'AppVersion', 'EngineVersion', 'Census_OSVersion' 
]

for col in numerical_categorical:
    data.loc[~data[col].isin(test[col].unique()), col] = -1

for col in categorical:
    data[col] = data[col].cat.add_categories([-1])
    data.loc[~data[col].isin(test[col].unique()), col] = -1


cols = list(data.columns)
for col in data.columns:
    rate = data[col].value_counts(normalize=True, dropna=False).values[0]
    if rate > 0.95:
        cols.remove(col)

df=data[cols]        
df.shape
df.info()
df.groupby('HasDetections')['Census_ChassisTypeName'].count()
sns.countplot(df['HasDetections'])
df.groupby('Census_InternalPrimaryDisplayResolutionHorizontal')['Census_InternalPrimaryDisplayResolutionHorizontal'].count()
df.groupby('Census_OSEdition')['HasDetections'].count()
df.isnull().sum()

sns.countplot(x="SmartScreen", hue="HasDetections",  palette="PRGn", data=df)
plt.title("SmartScreen counts")
plt.xticks(rotation='vertical')
plt.show()

df['ram_cpu_ratio'] = df['Census_TotalPhysicalRAM'] / df['Census_ProcessorCoreCount']

def frequency_encoding(variable):
    t = pd.concat([df[variable], test[variable]]).value_counts().reset_index()
    t = t.reset_index()
    t.loc[t[variable] == 1, 'level_0'] = np.nan
    t.set_index('index', inplace=True)
    max_label = t['level_0'].max() + 1
    t.fillna(max_label, inplace=True)
    return t.to_dict()['level_0']

for col in tqdm(numerical_categorical):
    freq_enc_dict = frequency_encoding(col)
    data[col] = data[col].map(lambda x: freq_enc_dict.get(x, np.nan)).astype('float32')
    test[col] = test[col].map(lambda x: freq_enc_dict.get(x, np.nan)).astype('float32')
    
for col in tqdm(categorical):
    freq_enc_dict = frequency_encoding(col)
    data[col] = data[col].map(lambda x: freq_enc_dict.get(x, np.nan)).astype('float32')
    test[col] = test[col].map(lambda x: freq_enc_dict.get(x, np.nan)).astype('float32')

# fast & efficient way to calculate mean using numba
@jit(parallel=True)
def mean_score(array):
    return np.mean(array)

# fast & efficient way to calculate division using numba
@jit(parallel=True)
def jit_div(array, divisor):
    return np.divide(array, divisor)

def run_lgb(train, target, test):
    global clf
    
    kf = KFold(n_splits=3, shuffle=True)

    train_scores = []
    cv_scores = []
    train_predictions = np.zeros(train.shape[0], dtype='float32')
    test_predictions = np.zeros(test.shape[0], dtype='float32')
    
    for (train_index, test_index) in tqdm(kf.split(train, target)):
        x_train, y_train = train.iloc[train_index], target.iloc[train_index]
        x_test, y_test = train.iloc[test_index], target.iloc[test_index]

        clf = lgb.LGBMClassifier(boosting_type='gbdt', 
                                 num_leaves=250, 
                                 n_estimators=2000, 
                                 learning_rate=0.02)

        clf.fit(x_train, y_train, eval_metric='auc',  
                eval_set=[(x_test, y_test)], 
                verbose=200,
                early_stopping_rounds=100)
        pred = clf.predict(x_train)
        score = roc_auc_score(y_train, pred)
        train_scores.append(score)

        pred = clf.predict(x_test)
        score = roc_auc_score(y_test, pred)
        cv_scores.append(score)
        
        # predict probabilities for train
        pred_prob = clf.predict_proba(train)[:,1]
        train_predictions = np.add(train_predictions, pred_prob).astype('float32')
        
        # predict probabilities for test
        pred_prob = clf.predict_proba(test)[:,1]
        test_predictions = np.add(test_predictions, pred_prob).astype('float32')
    
    print(f'training sklearn auc: {mean_score(train_scores):.4f}')
    print(f'3-fold CV sklearn auc: {mean_score(cv_scores):.4f}')

    return jit_div(train_predictions, 3), jit_div(test_predictions, 3)

target = data['HasDetections']
data.drop(['MachineIdentifier', 'HasDetections'], inplace=True, axis=1)
test.drop(['MachineIdentifier'], inplace=True, axis=1)

train_predictions, test_predictions = run_lgb(data, target, test)

feat_imp = pd.Series(clf.feature_importances_, index=data.columns)
feat_imp.nlargest(30).plot(kind='barh', figsize=(10,10))

sns.kdeplot(train_predictions)
plt.show()